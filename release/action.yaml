name: 'Custom Semantic Release Action'
description: 'A reusable and customizable action for standardized release workflows using semantic release.'
branding:
  icon: 'package'
  color: 'blue'

inputs:
  github-token:
    description: 'Github Token. Either the default GITHUB_TOKEN or a PAT can be used.'
    required: true
  ssh-key:
    description: 'SSH key for checkout. If provided, it will be used for checkout; otherwise, the default GITHUB_TOKEN will be used.'
    required: false
  node-version:
    description: 'Node version for setup.'
    default: '20'
    required: false
  semantic-version:
    description: 'Semantic version for release.'
    default: '24.2.0'
    required: false
  debug:
    description: 'Debug flag for semantic release (optional).'
    required: false
    default: 'true'
  dry-run:
    description: 'Whether to run semantic release in dry-run mode (optional).'
    default: 'false'
    required: false
  tag-prefix:
    description: 'Add prefix for generated Tag'
    required: false
    default: 'v'
  tag-suffix:
    description: 'Add a suffix for generated Tag'
    required: false
    default: ''
  extra-plugins:
    description: 'Additional semantic-release plugins to install (one per line). Default includes changelog and git plugins.'
    required: false
    default: |
      @semantic-release/changelog
      @semantic-release/git
  no-ci:
    description: 'Skip CI detection (useful for testing in PR context)'
    required: false
    default: 'false'
  skip-checkout:
    description: 'Skip the checkout step (useful when checkout is already done in workflow)'
    required: false
    default: 'false'
  github-ref-override:
    description: 'Override GITHUB_REF for branch detection (useful for PR testing)'
    required: false
    default: ''

outputs:
  new_release_published:
    description: 'Whether a new release was published. The return value is in the form of a string. ("true" or "false")'
    value: ${{ steps.semantic.outputs.new_release_published }}
  new_release_version:
    description: 'Version of the new release. (e.g. "1.3.0")'
    value: ${{ steps.semantic.outputs.new_release_version }}

runs:
  using: 'composite'
  steps:
    - name: Checkout code
      if: inputs.skip-checkout != 'true'
      uses: actions/checkout@v4
      with:
        ssh-key: ${{ inputs.ssh-key }}
        token: ${{ inputs.github-token }}
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ inputs.node-version }}

    - name: Install semantic-release and plugins
      shell: bash
      run: |
        set -e

        echo "=== Installing semantic-release and plugins ==="

        # Convert multi-line extra-plugins input to space-separated list
        PLUGINS_INPUT="${{ inputs.extra-plugins }}"
        PLUGINS_LIST=$(echo "$PLUGINS_INPUT" | tr '\n' ' ' | xargs)

        echo "Semantic-release version: ${{ inputs.semantic-version }}"
        echo "Additional plugins: $PLUGINS_LIST"

        # Check if package.json exists
        PACKAGE_JSON_EXISTS=false
        if [ -f "package.json" ]; then
          PACKAGE_JSON_EXISTS=true
          echo "Found existing package.json"
        else
          echo "No package.json found, creating minimal one"
          echo '{"private": true, "name": "temp-semantic-release"}' > package.json
        fi

        # Install semantic-release and plugins
        # Using --no-save to avoid modifying package.json unnecessarily
        # Using --legacy-peer-deps to handle potential peer dependency conflicts
        npm install --no-save --legacy-peer-deps \
          semantic-release@${{ inputs.semantic-version }} \
          $PLUGINS_LIST

        # Clean up package.json if we created it
        if [ "$PACKAGE_JSON_EXISTS" = "false" ]; then
          echo "Removing temporary package.json"
          rm -f package.json package-lock.json
        fi

        echo "✓ Installation complete"

    - name: Run semantic-release
      id: semantic
      shell: bash
      run: |
        set -e

        echo "=== Running semantic-release ==="

        # Set debug mode if enabled
        if [ "${{ inputs.debug }}" = "true" ]; then
          export DEBUG="semantic-release:*"
          echo "Debug mode enabled"
        fi

        # Prepare semantic-release command
        SR_CMD="npx semantic-release"
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          SR_CMD="$SR_CMD --dry-run"
          echo "Running in DRY-RUN mode (no actual release will be created)"
        fi
        if [ "${{ inputs.no-ci }}" = "true" ]; then
          SR_CMD="$SR_CMD --no-ci"
          echo "CI detection disabled (--no-ci flag enabled)"
        fi
        if [ -n "${{ inputs.github-ref-override }}" ]; then
          # Extract branch name from refs/heads/branch-name
          BRANCH_NAME="${{ inputs.github-ref-override }}"
          BRANCH_NAME="${BRANCH_NAME#refs/heads/}"
          SR_CMD="$SR_CMD --branches $BRANCH_NAME"
          echo "Branch override: $BRANCH_NAME"
        fi

        # Run semantic-release and capture output
        OUTPUT_FILE=$(mktemp)
        echo "Executing: $SR_CMD"
        echo ""

        # Run semantic-release with output capture
        set +e  # Don't exit on error, we need to process output
        $SR_CMD 2>&1 | tee "$OUTPUT_FILE"
        SR_EXIT_CODE=${PIPESTATUS[0]}
        set -e

        echo ""
        echo "=== Parsing semantic-release output ==="

        # Initialize outputs with defaults
        NEW_RELEASE_PUBLISHED="false"
        NEW_RELEASE_VERSION=""

        # Parse output for release information
        # Look for patterns like:
        # - "Published release 1.2.3" (success case)
        # - "There are no relevant changes" (no release case)
        # - "The next release version is X.Y.Z" (version determination)

        if grep -q "Published release" "$OUTPUT_FILE"; then
          NEW_RELEASE_PUBLISHED="true"
          # Extract version number from "Published release X.Y.Z" or similar
          NEW_RELEASE_VERSION=$(grep -oP "Published release \K[0-9]+\.[0-9]+\.[0-9]+" "$OUTPUT_FILE" | head -n 1)
          echo "✓ Release published: $NEW_RELEASE_VERSION"
        elif grep -qE "(There are no relevant changes|no new version|skip release)" "$OUTPUT_FILE"; then
          NEW_RELEASE_PUBLISHED="false"
          echo "ℹ No new release (no relevant changes)"
        elif grep -q "The next release version is" "$OUTPUT_FILE"; then
          # Dry-run mode shows what version would be released
          NEW_RELEASE_VERSION=$(grep -oP "The next release version is \K[0-9]+\.[0-9]+\.[0-9]+" "$OUTPUT_FILE" | head -n 1)
          if [ "${{ inputs.dry-run }}" = "true" ]; then
            NEW_RELEASE_PUBLISHED="false"
            echo "ℹ Dry-run mode: would publish version $NEW_RELEASE_VERSION"
          else
            NEW_RELEASE_PUBLISHED="true"
            echo "✓ Release determined: $NEW_RELEASE_VERSION"
          fi
        fi

        # Set GitHub Actions outputs
        echo "new_release_published=$NEW_RELEASE_PUBLISHED" >> $GITHUB_OUTPUT
        echo "new_release_version=$NEW_RELEASE_VERSION" >> $GITHUB_OUTPUT

        echo ""
        echo "=== Outputs ==="
        echo "new_release_published: $NEW_RELEASE_PUBLISHED"
        echo "new_release_version: $NEW_RELEASE_VERSION"

        # Clean up
        rm -f "$OUTPUT_FILE"

        # Exit with semantic-release exit code
        if [ $SR_EXIT_CODE -ne 0 ]; then
          echo ""
          echo "❌ semantic-release failed with exit code $SR_EXIT_CODE"
          exit $SR_EXIT_CODE
        fi

        echo ""
        echo "✓ semantic-release completed successfully"
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GITHUB_REF: ${{ inputs.github-ref-override != '' && inputs.github-ref-override || github.ref }}
        GITHUB_EVENT_NAME: ${{ inputs.github-ref-override != '' && 'push' || github.event_name }}
        GIT_AUTHOR_NAME: ${{ github.actor }}
        GIT_AUTHOR_EMAIL: ${{ github.actor }}@users.noreply.github.com
        GIT_COMMITTER_NAME: ${{ github.actor }}
        GIT_COMMITTER_EMAIL: ${{ github.actor }}@users.noreply.github.com
